[![By ULHPC](https://img.shields.io/badge/by-ULHPC-blue.svg)](https://hpc.uni.lu) [![Licence](https://img.shields.io/badge/license-GPL--3.0-blue.svg)](http://www.gnu.org/licenses/gpl-3.0.html) [![GitHub issues](https://img.shields.io/github/issues/ULHPC/tutorials.svg)](https://github.com/ULHPC/tutorials/issues/) [![](https://img.shields.io/badge/slides-PDF-red.svg)](https://github.com/ULHPC/tutorials/raw/devel/data/slides.pdf) [![Github](https://img.shields.io/badge/sources-github-green.svg)](https://github.com/ULHPC/tutorials/tree/devel/data/) [![Documentation Status](http://readthedocs.org/projects/ulhpc-tutorials/badge/?version=latest)](http://ulhpc-tutorials.readthedocs.io/en/latest/data/) [![GitHub forks](https://img.shields.io/github/stars/ULHPC/tutorials.svg?style=social&label=Star)](https://github.com/ULHPC/tutorials)

# Data Management on UL HPC Facility

     Copyright (c) 2020 UL HPC Team <hpc-sysadmins@uni.lu>

Author: Sarah Peter

<!-- [![](https://github.com/ULHPC/tutorials/raw/devel/data/cover_slides.png)](https://github.com/ULHPC/tutorials/raw/devel/data/slides.pdf) -->

**Note:** To make it clear where you should execute a certain command, the prompt is prefixed with the location, i.e.

- `(access)$>` for commands on the cluster access/login nodes
- `(node)$>` for commands on a cluster node inside a job
- `(laptop)$>` for commands locally on your machine

The actual command comes only after this prefix.

## Preliminaries

#### 1. Connect to the cluster

#### 2. Start an interactive job

```
(access)$> si
```

#### 3. Prepare data

```bash
(node)$> mkdir -p $SCRATCH/data_management
(node)$> cd $SCRATCH/data_management
(node)$> echo "Happy secure computing!" > message.txt
```

## Checksums

Integrity of data files is critical for the verifiability of computational and lab-based analyses. The way to seal a data file's content at a point in time is to generate a checksum. Checksum is a small sized datum generated by running an algorithm, called a cryptographic hash function, on a file. As long as a data file does not  change, the calculation of the checksum will always result in the same datum. If you recalculate the checksum and it is different from a past calculation, then you know the file has been **altered** or **corrupted** in some way.

Below are typical situations that call for checksum generation:

- A data file has been newly downloaded or received from a collaborator.
- You have copied data files to a new storage location, for instance you moved data from local computer to HPC to start an analysis. You want to create a snapshot of your data, for instance when you’re creating a supplementary material folder for a paper/report.

### MD5

The MD5 hash function produces a 128-bit hash value. It was designed for use in cryptography, but vulnerabilities were discovered over the course of time, so it is no longer recommended for that purpose. However, it is still used for database partitioning and computing checksums to validate files transfers.

```bash
(node)$> md5sum message.txt
```

Save to file:

```bash
(node)$> md5sum message.txt > message.md5
```

Given a data file and its checksum, one can **verify** the file against the checksum with the following command.

```bash
(node)$> md5sum -c message.md5
message.txt: OK
```

Change file:

```bash
(node)$> echo "This file has been changed." >> message.txt
(node)$> md5sum message.txt
(node)$> md5sum -c message.md5
```



### SHA

SHA stands for Secure Hash Algorithm. The first version of the algorithm was SHA-1, and was later followed by SHA-2 (see below).

The second version of SHA, called SHA-2, has many variants. Probably the one most commonly used is SHA-256, which the National Institute of  Standards and Technology (NIST) recommends using instead of MD5 or SHA-1. 

The SHA-256 algorithm returns hash value of 256-bits, or 64 hexadecimal  digits. While not quite perfect, current research indicates it is  considerably more secure than either MD5 or SHA-1. 

```bash
(node)$> shasum -a 256 my_file.csv > my_file.sha256
```

Given a data file and its checksum, one can **verify** the file against the checksum with the following command.

```bash
(node)$> shasum -c my_file.sha256
my_file.csv: OK
```



## Encryption

Encryption is an effective measure to protect sensitive data. In this lab card we provide instructions for file/folder encryption on  platforms commonly used by LCSB staff.

**IMPORTANT NOTICE:** One important requirement of using Encryption is that you must  manage your Encryption Passwords/Keys.  Failing to do so will mean **loosing your data indefinitely**. In this [link](https://howto.lcsb.uni.lu/external/integrity/passwords/) we list  tools that can be used for password management. **Please make sure you have arrangements for password management before starting the encryption of data**.

### GPG

Make sure you have all relevant data in a single file. In case you  have multiple files, put them in a folder and create a compressed  archive (aka tarball).

```
tar cvzf your-compressed-file-name.tar.gz your-directory/
```

You can use the below command to encrypt a file on Linux.

```
gpg -c file_to_be_encrypted
```

You will be asked for a passphrase.

```
Enter passphrase:<YOUR_PASSWORD>
Repeat passphrase:<YOUR_PASSWORD>
```

The following command can be used to decrypt the file.

```
gpg  encrypted_file
```

Instead of using a passphrase, you can also encrypt files using an  encryption key. You can use GPG to create an encryption key as follows.

```
gpg --gen-key
```

### gocryptfs

To use **gocryptfs** on the HPC platform you need:

1. to load its profile from the modules system
2. to create two folders:    
   - one which will act as the storage for the encrypted files (let’s call it *crypt*)
   - the other will present (on demand) the unencrypted view (let’s call it *view*)
3. to initialize the *crypt* folder with a password
4. to mount the *crypt* folder into the *view* folder
5. all your processing (new file/folder creation, modification and transfers) will happen in the *view* folder
6. to unmount the *view* folder such that the unencrypted view of your data is closed and data is flushed to the regular filesystem

For example, to create a new encrypted store in a folder named **dir.crypt** , open the unencrypted view in a folder named **dir**, create a test file inside and close the view:

```bash
$ srun -N 1 -n 1 -p interactive --time=0:10:0 --pty bash -i
    $ module load tools/gocryptfs
    $ mkdir dir.crypt dir
    $ gocryptfs -init dir.crypt
    Choose a password for protecting your files.
    Password: 
    Repeat: 
    
    Your master key is:
    
        e1ecdcf1-6bcebaa0-cbe6cfb8-8e27d4ad-
        acefb9d4-bd98de59-311d1898-31d7e4e4
    
    If the gocryptfs.conf file becomes corrupted or you ever forget your password,
    there is only one hope for recovery: The master key. Print it to a piece of
    paper and store it in a drawer. This message is only printed once.
    
    The gocryptfs filesystem has been created successfully.
    You can now mount it using: gocryptfs dir.crypt MOUNTPOINT
    
    $ ls dir.crypt/
    gocryptfs.conf  gocryptfs.diriv
    $ ls dir
    $ gocryptfs dir.crypt dir
    Password: 
    Decrypting master key
    Filesystem mounted and ready.
    $ ls dir
    $ echo "Happy secure computing" > dir/message.txt
    $ ls dir
    message.txt
    $ ls dir.crypt/
    5o_WSYN-Tn59W3vrPiHXEA  gocryptfs.conf  gocryptfs.diriv
    $ fusermount -u dir
    
    $ ls dir
    $ ls dir.crypt/
    5o_WSYN-Tn59W3vrPiHXEA  gocryptfs.conf  gocryptfs.diriv
    
    $ gocryptfs -masterkey e1ecdcf1-6bcebaa0-cbe6cfb8-8e27d4ad-acefb9d4-bd98de59-311d1898-31d7e4e4 dir.crypt/ dir
    Using explicit master key.
    THE MASTER KEY IS VISIBLE VIA "ps ax" AND MAY BE STORED IN YOUR SHELL HISTORY!
    ONLY USE THIS MODE FOR EMERGENCIES
    Filesystem mounted and ready.
    $ ls dir
    message.txt
    $ cat dir/message.txt 
    Happy secure computing
    
    $ ls -l dir/message.txt 
    -rw-r--r-- 1 vplugaru clusterusers 23 Dec 14 15:14 dir/message.txt
    $ ls -l dir.crypt/5o_WSYN-Tn59W3vrPiHXEA 
    -rw-r--r-- 1 vplugaru clusterusers 73 Dec 14 15:14 dir.crypt/5o_WSYN-Tn59W3vrPiHXEA
    
    $ chmod o-r dir/message.txt 
    $ ls -l dir/message.txt 
    -rw-r----- 1 vplugaru clusterusers 23 Dec 14 15:14 dir/message.txt
    $ ls -l dir.crypt/5o_WSYN-Tn59W3vrPiHXEA 
    -rw-r----- 1 vplugaru clusterusers 73 Dec 14 15:14 dir.crypt/5o_WSYN-Tn59W3vrPiHXEA
    $ fusermount -u dir
```

Several important elements can be seen in the above transcript:

1. On *crypt* store initialization, gocryptfs provides us with the master key that can be used to restore access to the data files,  especially useful in case the password is lost    

   - you should keep the master key safe, never store it unencrypted on the platform itself

2. After initialization, the *crypt* store contains two internal configuration files: 

   ```
   gocryptfs.conf
   ```

    is the global configuration for the *crypt* store, while 

   ```
   gocryptfs.diriv
   ```

    is created per-directory for encryption of file names    

   - note that you should never modify (any) files within the *crypt* store

3. To be able to access/store data, the *crypt* store needs to be mounted in the *view* folder    

   - this can be done by supplying the initially set password, either on the command line or from a file with `-passfile` option
   - … or with the generated master key, with the `-masterkey` option
   - with the passfile option, it means that you have stored your  password unencrypted on the filesystem - this is then a security risk!
   - when using the master key mode, you should be in a full-node  or exclusive job reservation such that there are no other users able to  see the master key in the system

4. Once the *crypt* store is mounted in the *view* directory we can create files in the latter:    

   - any folder/file created in the unencrypted view will have a 1:1 correspondent in the *crypt* store
   - the plain text `message.txt` file is stored in encrypted format as `5o_WSYN-Tn59W3vrPiHXEA` in the underlying *crypt* store (file name metadata is encrypted as well)
   - the same permissions applied on `message.txt` are also set for its encrypted correspondent file

5. At the end of our processing, we are using 

   ```
   fusermount
   ```

    explicitly to unmount the encrypted overlay    

   - note that you should always ensure that this happens before your job reservation expires

Other important details:

- On the Iris cluster the mounted encryption overlay is tied to the job context, when the job ends the overlay is destroyed;

- Data stored in a *crypt* store should not be used concurrently (e.g. by multiple users at the same time)    

  - the [special option](https://github.com/rfjakob/gocryptfs/blob/master/Documentation/MANPAGE.md#-sharedstorage) `-sharedstorage` exists for this use-case, but is not guaranteed to work for all applications;

- (Parallel) Applications ran through 

  ```
  srun
  ```

   on the Iris cluster cannot "see" the unencrypted *view* folder as they are run in a different context;    

  - this is also the case if you use `sjoin` or `srun --jobid` to attach your terminal to a running job;

#### Gocryptfs store password management

- You can change the password of an existing *crypt* store with the `-passwd` option:

  ```
    gocryptfs -passwd dir.crypt/
    Password: [your current password here]
    Decrypting master key
    Please enter your new password.
    Password: [your new password here]
    Repeat: [your new password here]
    Password changed.
  ```

Note that the master key *does not change*.

- For running batch processing on a gocryptfs-based, you can  provide the decryption password through an external application with the `-extpass` option:

  ```
    gocryptfs -extpass "echo foobar" dir.crypt dir
    Reading password from extpass program
    Decrypting master key
    Filesystem mounted and ready.
  ```

Note that this means that another application stores/has access to the password - this is then a security risk!

## References

* https://www.freecodecamp.org/news/md5-vs-sha-1-vs-sha-2-which-is-the-most-secure-encryption-hash-and-how-to-check-them/
* https://howto.lcsb.uni.lu/external/integrity/checksum/
* https://howto.lcsb.uni.lu/external/integrity/encryption/file/

## Acknowledgements

Many thanks to Valentin Plugaru for the initial version of the gocryptfs part.

